= Memuser API Guide
Gary Clayburg;
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 4
:sectlinks:
:sectnums:

[[overview]]
== Overview

Memuser is a simple tool for storing and retrieving user information.  All data is stored in memory, nothing is persisted.  The API used is based loosely on the http://www.simplecloud.info[SCIM protocol], which is essentially JSON with some standardized semantics.

*Why?* Memuser was created to help with testing some security integration scenarios without having to deal with the overhead of persisting user information.  We want to be able to test out User data integration scenarios and not worry so much about the normal data lifecycle issues.  Of course, real systems will need to deal with these issues, but we don't want to hinder our ability to model the lifecycle of user information when we are building out our user security model.


If you have a tool that can provision SCIM users, you can probably use it to manage users in Memuser.

[[Startup]]
== Starting

=== From a docker image
The easiest way to start memuser is with https://www.docker.com/[docker]:
----
$ docker run --rm  -d -p9080:8080 --name memuser gclayburg/memuser
----

When finished, stop it with:

----
$ docker stop memuser
----

=== From source
You could also run the application as a standalone jar file once you build it yourself:

----
$ git clone git@github.com:gclayburg/memuser.git
$ cd memuser
$ ./gradlew build
$ ls -l build/libs/*jar
$ java -jar build/libs/memuser-0.9.1-SNAPSHOT.jar
----

NOTE: Make sure you specify the correct version you built.

Stop it with Ctrl-c

[[create-user]]
== Create Minimal User

=== request

Let's jump into creating a user.  When Memuser is started, there are no users loaded.  Let's create one:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/createalice/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/createalice/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/createalice/http-request.adoc[]

TIP: We show 3 different ways to generate a JSON request - the ubiquitous https://curl.haxx.se/[cURL], https://httpie.org/[HTTPie] and raw HTTP

=== response
include::{snippets}/createalice/http-response.adoc[]

This is a minimal user.  Only the `userName` field is required.

The returned JSON response includes the exact user that the Memuser server created. The extra fields are per the https://tools.ietf.org/html/rfc7643#section-8.1[SCIM spec].

== GET User

=== request

Take a look at the `id` field.  This was generated by Memuser and is guaranteed to be unique and never changing among all users that it knows about.  `id` is also part of `meta.location`.  We can use this field to retrieve our generated user:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/getalice/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/getalice/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/getalice/http-request.adoc[]

=== response
include::{snippets}/getalice/http-response.adoc[]

== Duplicate userName

Lets try creating alice again:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/createalice/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/createalice/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/createalice/http-request.adoc[]

=== response
include::{snippets}/duplicatealicesmith/http-response.adoc[]

`userName` must be unique.

== FAQ

=== Why is there both a `userName` and `id`?

One reason is that this allows users to change their userName in Memuser without necessarily notifying clients.  For example, lets say Alice gets married to Tom Jones.  She changes her last name from Smith to Jones.  Alice is happy.  She comes in to work on Monday and updates her HR records to change her last name to Smith.  She would like to log on to her computer with alicejones and not alicesmith.  It sounds like a simple request, but it can cause headaches when we are dealing with many interconnected IT systems that require user identity.  There may be multiiple places that need to get updated.  If they aren't all updated, Alice would at best see strange errors.

So instead, we store the initial userName in Memuser when we first create the user on behalf of the client.  Our client stores a reference to it using the unique `id`.  The client may also keep track of the `userName`, but it realizes this `userName` stored in Memuser could change at any point.  Since the client knows Alice by her `id` and not `userName`, it may not even need to be updated when the `userName` changes in Memuser.

=== Does the client or server have the most accurate `userName`?
There is nothing in the SCIM protocol itself to determine this.  It is up to you to determine a convention that works for your workflow.  You will need to decide where the authoritative sources are for each user attribute.  The SCIM protocol really shines in simplifying and standardizing how independent but related user domains can reason about user relationships.

== Change userName

=== request

[source,indent=0,role="primary"]
.cURL
include::{snippets}/changeusername/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/changeusername/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/changeusername/http-request.adoc[]

=== response
include::{snippets}/changeusername/http-response.adoc[]

Alice's userName changes, the `id` and `meta.location` do not.

NOTE:  Notice `displayName` no longer exists for Alice.  We changed the existing Alice with a PUT request.  Memuser will replace the entire user with what was sent in the request.

== Replace entire User

=== request

If we want Memuser to retain all user fields during a userName change, we need to send a full PUT request like this:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/changeusernamedisplayname/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/changeusernamedisplayname/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/changeusernamedisplayname/http-request.adoc[]

=== response
include::{snippets}/changeusernamedisplayname/http-response.adoc[]


== Create user with full name

=== request

Lets create a user with a few more fields:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/createtom/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/createtom/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/createtom/http-request.adoc[]

=== response
include::{snippets}/createtom/http-response.adoc[]

The fields included here are optional `name` fields documented in the https://tools.ietf.org/html/rfc7643#section-8.1[SCIM spec].


== Create arbitrary User

=== request

We can also create a Memuser user with fields that aren't necessarily https://tools.ietf.org/html/rfc7643#section-4.1[SCIM defined User resource fields]:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/createharry/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/createharry/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/createharry/http-request.adoc[]

=== response
include::{snippets}/createharry/http-response.adoc[]

Here, we are using Memuser to model an application that expects users to have a `mailcode` and `emailaddress` top-level field.  Notice we did not define `mailcode` or `emailaddress` anywhere.  Memuser is dynamic.  It does not know ahead of time if these fields should be stored as an integer, string or some other datatype.  It doesn't even have a notion of data validation.  This is by design.  Other than fields like `id` and `userName`, <<Rigid User Fields,Memuser does not enforce a rigid definition of what fields are required or allowed for users>>.  JSON is flexible and so is Memuser.  Data validation is left up to the client.

== Get User List

=== request

Here is a standard SCIM style request to retrieve a list of our users:

[source,indent=0,role="primary"]
.cURL
include::{snippets}/getlist/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/getlist/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/getlist/http-request.adoc[]

=== response
include::{snippets}/getlist/http-response.adoc[]

The list is formatted according to the https://tools.ietf.org/html/rfc7644#section-3.4.2[SCIM ListResponse]

== Rigid User Fields

|===
| Field | Special Notes

| `userName` | required for every user; must be unique among all users
| `id` | unique identifier generated by Memuser for each new user
| `password` | ignored
|===

[[overview-http-verbs]]
== HTTP verbs

RESTful notes tries to adhere as closely as possible to standard HTTP and REST conventions in its
use of HTTP verbs.

|===
| Verb | Usage

| `GET`
| Used to retrieve a resource

| `POST`
| Used to create a new resource

| `PATCH`
| Used to update an existing resource, including partial updates

| `DELETE`
| Used to delete an existing resource
|===

[[overview-http-status-codes]]
== HTTP status codes

RESTful notes tries to adhere as closely as possible to standard HTTP and REST conventions in its
use of HTTP status codes.

|===
| Status code | Usage

| `200 OK`
| The request completed successfully

| `201 Created`
| A new resource has been created successfully. The resource's URI is available from the response's
`Location` header

| `204 No Content`
| An update to an existing resource has been applied successfully

| `400 Bad Request`
| The request was malformed. The response body will include an error providing further information

| `404 Not Found`
| The requested resource did not exist
|===

[[overview-errors]]
== Troubleshooting

Memuser is based on spring boot, so there are a few settings that can be adjusted.  These examples show the configuration in the properties file format, but there are many other ways settings are https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/boot-features-external-config.html[externalized in spring boot], including environment variables, command line parameters and yaml.

=== startup
If you have troubles starting up, try turning on debug from https://github.com/gclayburg/upbanner[upbanner]:

[source,properties,configprops]
----
upbanner.debug=true <1>
memuser.show-headers=true <2>
memuser.user-count=10000 <3>
----
<1> on startup, print out many debugging details to the stdout log about the environment it is running on
<2> show all http headers to the stdout log
<3> on startup, add 10000 users to the domain, default is 0.

== Security

=== password

The `password` field can be specified in a user create request or a change request, but per the SCIM spec, the value is never returned in clear text.  Memuser goes one step further and does not even store `password`.  However, this is only true for the password field named exactly `password`.

[source,indent=0,role="primary"]
.cURL
include::{snippets}/createbill/curl-request.adoc[]

[source,indent=0,role="secondary"]
.HTTPie
include::{snippets}/createbill/httpie-request.adoc[]

[source,indent=0,role="secondary"]
.http
include::{snippets}/createbill/http-request.adoc[]

==== response
include::{snippets}/createbill/http-response.adoc[]



=== TLS/HTTPS support

For convenience, there is a TLS certificate bundled for the hostname `gibberishhostname.example.com`.  It is only intended to be used testing purposes.  It is signed by a self-signed CA certificate, and not by any well known trusted CA.

To use this certificate and require memuser to be accessed over TLS, you'll need to set properties like this.  The `server.port` can be adjusted, but the rest can not if you use the bundled `insecuretlswrapperwithgibberishhostname.p12` file.

[source,yaml,configblocks]
----
security:
  require-ssl: true
server:
  port: 443
  ssl:
    key-store: classpath:insecuretlswrapperwithgibberishhostname.p12
    key-store-password: changeit
    key-store-type: PKCS12
    key-alias: gibberishhostname

----

=== Authentication

By default, there is no authentication required to make http requests to memuser.  However, memuser
can be deployed to require basic authentication.

==== Basic Authentication defaults

Set this property to require basic authentication credentials:

----
spring.profiles.active=secure
----

This will force clients to supply basic authentication credentials.  The username is "user". The password is "password".

==== Custom username and password

If you want to use your own credentials, set environment variables named MEMUSER_USERNAME and MEMUSER_PASSWORD.  For example, lets use scott/tiger:

----
MEMUSER_USERNAME=scott
MEMUSER_PASSWORD=tiger
----
