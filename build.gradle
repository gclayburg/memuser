import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import org.ajoberstar.grgit.operation.OpenOp

import java.time.ZonedDateTime

buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath "org.asciidoctor:asciidoctor-gradle-plugin:${asciidoctorVersion}"
        classpath "org.kordamp.gradle:livereload-gradle-plugin:0.2.1"
        classpath 'org.ajoberstar:grgit:1.1.0'
    }
}

plugins {
    id "com.gorylenko.gradle-git-properties" version "1.4.17"
    id "com.bmuschko.docker-remote-api" version "3.1.0"
}

apply plugin: 'groovy'
apply plugin: 'org.springframework.boot'
apply plugin: 'application'
apply plugin: 'org.asciidoctor.convert'
apply plugin: 'codenarc'
apply plugin: 'org.kordamp.gradle.livereload'

group = "${group}"

jar {
    dependsOn asciidoctor
    from ("${asciidoctor.outputDir}/html5") {
        into 'static/docs'
    }
}

repositories {
    mavenCentral()
    maven {
        url "https://repo.spring.io/release"
    }

}

dependencies {
    compile 'org.springframework.boot:spring-boot-devtools'
    compile 'org.codehaus.groovy:groovy-all'
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.springframework.boot:spring-boot-starter-actuator'
    compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'
    testCompile 'org.springframework.boot:spring-boot-starter-test'
    testCompile "org.spockframework:spock-spring:${spockVersion}"
    testCompile "org.spockframework:spock-core:${spockVersion}"
    testCompile 'com.jayway.jsonpath:json-path-assert:0.8.1'
    testCompile "org.springframework.restdocs:spring-restdocs-mockmvc:${springRestDocsVersion}"
}

ext {
    snippetsDir = file('target/generated-snippets')
    def openOp = new OpenOp(dir: project.rootDir)
    git = openOp.call()
    revision = git.head().id
    gitchanges = getGitStatus()
    build_date = ZonedDateTime.now().toString()

}
processResources{
    expand(project.properties)
}
gitProperties {
    dateFormat = "yyyy-MM-dd'T'HH:mmZ"
    dateFormatTimeZone = "America/Denver"
}

asciidoctor {
    dependsOn test
    sourceDir = file('src/main/asciidoc')
    outputDir "build/asciidoc"
    inputs.dir snippetsDir
    backends 'html5'
    dependencies {
        asciidoctor 'io.spring.asciidoctor:spring-asciidoctor-extensions:0.1.0.RELEASE'
    }

    attributes 'source-highlighter' : 'prettify',
            'imagesdir':'images',
            'toc':'left',
            'icons': 'font',
            'setanchors':'true',
            'idprefix':'',
            'idseparator':'-',
            'docinfo1':'true',
            'snippets': snippetsDir
}

liveReload {
    description = "run in a terminal window, view docs in browser http://localhost:35729/html5/api.html"
    docRoot asciidoctor.outputDir.canonicalPath
    dependsOn asciidoctor
}

task cleanTempDir(type: Delete) {
    delete fileTree(dir: 'src/main/resources/public')
}

clean {
    dependsOn cleanTempDir
}

build {
    dependsOn asciidoctor
}

final dockerBuildDir = "${project.buildDir.absolutePath}/docker"

task createDependenciesLayer(type: Copy, dependsOn: bootRepackage){
    from zipTree(jar.archivePath)
    into "${dockerBuildDir}/dependenciesLayer"
    exclude "/BOOT-INF/classes/**"
    exclude "/META-INF/**"
}

task createClassesLayer(type: Copy, dependsOn: createDependenciesLayer){
    from zipTree(jar.archivePath)
    into "${dockerBuildDir}/classesLayer"
    include "/BOOT-INF/classes/**"
    exclude "/META-INF/**"
}

task copyDockerResources(type: Copy, dependsOn: createClassesLayer){
    from "${project.rootDir}/src/main/docker"
    into dockerBuildDir
}
springBoot{
    buildInfo{
        additionalProperties =[
                'org.label-schema.vcs-ref':git.head().id,
                'org.label-schema.vcs-url':vcsurl,
                'org.label-schema.description':gitchanges,
                'org.label-schema.build-date':build_date,
        ]
    }
}

task buildImage(type: DockerBuildImage, dependsOn: copyDockerResources){
    description = "build and tag a Docker Image"
    inputDir = project.file(dockerBuildDir)
    tags = [dockerimage+':' + version, dockerimage +':latest']

    if (project.hasProperty('dockerhubimage')){
        println('configure dockerhub images')
        tags.add(dockerhubimage + ':' + version)
        tags.add(dockerhubimage + ':latest')

    }
    println "boot " + bootBuildInfo.getProjectVersion()
    String gitchanges = getGitStatus()
    buildArgs = ['VCS_REF'    :git.head().id,
                 'VCS_URL'    :vcsurl,
                 'BUILD_DATE' : build_date,
                 'VERSION'    :version,
                 'DESCRIPTION': "$gitchanges",
    ]

}

private String getGitStatus() {
    String gitchanges = ''
    def gitChangeList = []
    if (git.status().isClean()) {
        gitchanges = '[git: clean]'
    } else {
        if (git.status().staged.added.size() > 0)
            gitChangeList.add("${git.status().staged.added.size()} staged added")
        if (git.status().staged.modified.size() > 0)
            gitChangeList.add("${git.status().staged.modified.size()} staged modified")
        if (git.status().staged.removed.size() > 0)
            gitChangeList.add("${git.status().staged.removed.size()} staged removed")
        if (git.status().unstaged.added.size() > 0)
            gitChangeList.add("$gitchanges ${git.status().unstaged.added.size()} unstaged added")
        if (git.status().unstaged.modified.size() > 0)
            gitChangeList.add("$gitchanges ${git.status().unstaged.modified.size()} unstaged modified")
        if (git.status().unstaged.removed.size() > 0)
            gitChangeList.add("$gitchanges ${git.status().unstaged.removed.size()} unstaged removed")
        def join = gitChangeList.join(',')
        gitchanges = '[git: ' + join + ']'
    }
    gitchanges += ' ' + project.property('description')
    gitchanges
}

task pushVersion(type: DockerPushImage, dependsOn: buildImage) {
    description = "docker push <imageName>:<version>"
    imageName = dockerimage +":" + version
}

task pushLatest(type: DockerPushImage, dependsOn: buildImage) {
    description = "docker push <imageName>:latest"
    imageName = dockerimage +":latest"
}

/*
java -jar build/libs/memuser-0.5.0.jar

This is simlar to bootRun, except that we are executing the jar file instead of the exploded build dir.
This allows us to include static files like /docs/api.html
 */
task bootJarRun(type: JavaExec) {
    dependsOn bootRepackage
    main = "-jar"
    args jar.archivePath.getPath()
}

codenarcMain {
    ignoreFailures true
    configFile file('gradle/codenarc/codenarc.groovy')
}


codenarcTest {
    ignoreFailures true
    configFile file('gradle/codenarc/codenarcTest.groovy')
}

task publish(type: GradleBuild) {
    dependsOn asciidoctor
    buildFile = file('publish.gradle')
    tasks = ['publishGhPages']
}

ext['spring-restdocs.version'] = '1.2.1.RELEASE'

/*
gradle continuous build in one terminal:
$ cd dev/memuser
$ gradle asciidoctor -t

enable livereload in another terminal:
$ cd dev/memuser
$ gradle liveReload

in the browser open url http://localhost:35729/html5/api.html
-enable livereload browser plugin

maven resources plugin makes content available at:
http://localhost:8080/docs/api.html
 */